[gd_scene load_steps=2 format=3]

[sub_resource type="GDScript" id="GDScript_main"]
script/source = """
# Generated by Vector AI
extends Node2D

# Generated by Vector AI
extends Node2D

# --- Constants ---
const TILE_SIZE: int = 64 # Size of each tile (platform block) in pixels
const PLAYER_SPEED: float = 200.0 # Player horizontal movement speed
const JUMP_VELOCITY: float = -400.0 # Player vertical velocity when jumping (negative is upwards)
const GRAVITY: float = 800.0 # Gravity applied to the player

const PLATFORM_COLOR: Color = Color.html("#604020") # Brown for platforms
const PLAYER_COLOR: Color = Color.html("#4287f5") # Blue for the player
const GOAL_COLOR: Color = Color.html("#00FF00") # Green for the goal
const BACKGROUND_COLOR: Color = Color.html("#87CEEB") # Sky blue background

# Define the level structure (0 = empty, 1 = platform, 2 = player start, 3 = goal)
# This is a simple platformer level grid
const LEVEL_GRID: Array[Array[int]] = [
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], # Row 0 (Top)
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0], # Row 8: Goal
	[1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1], # Row 9: Platforms
	[1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1], # Row 10: Platforms
	[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], # Row 11: Platforms
	[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], # Row 12: Platforms
	[2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], # Row 13: Player Start
	[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  # Row 14 (Bottom): Ground
]

# --- Variables ---
var player: CharacterBody2D # Reference to the player node
var goal: Area2D # Reference to the goal node
var win_label: Label # Reference to the label displaying the win message
var game_won: bool = false # State variable to track if the game is won

# --- Ready Function ---
# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	# --- Setup Input Actions ---
	# IMPORTANT: For this script to work, you MUST configure input actions
	# in Project Settings -> Input Map. Add the following actions:
	# "move_left" (e.g., Left Arrow, A)
	# "move_right" (e.g., Right Arrow, D)
	# "jump" (e.g., Space, W, Up Arrow)
	# If these actions are not set up, the game will not respond to input.

	# --- Set Background Color ---
	# Create a solid background color rect filling the approximate viewport
	var background = ColorRect.new()
	background.color = BACKGROUND_COLOR
	# Set a large size, ideally this would adapt to viewport size changes
	background.size = Vector2(2000, 1200)
	add_child(background)

	# --- Create Level ---
	var level_container = Node2D.new()
	level_container.name = "LevelContainer"
	add_child(level_container)

	var player_start_pos: Vector2 = Vector2.ZERO
	var goal_pos: Vector2 = Vector2.ZERO

	for row_index in range(LEVEL_GRID.size()):
		for col_index in range(LEVEL_GRID[row_index].size()):
			var cell_type = LEVEL_GRID[row_index][col_index]
			var tile_position = Vector2(col_index * TILE_SIZE, row_index * TILE_SIZE)

			match cell_type:
				1: # Platform
					create_platform_tile(tile_position, level_container)
				2: # Player Start
					player_start_pos = tile_position + Vector2(TILE_SIZE / 2.0, TILE_SIZE / 2.0) # Center in cell
				3: # Goal
					goal_pos = tile_position + Vector2(TILE_SIZE / 2.0, TILE_SIZE / 2.0) # Center in cell
				0: # Empty space, do nothing
					pass

	# --- Create Player ---
	player = CharacterBody2D.new()
	player.name = "Player"
	player.global_position = player_start_pos # Use the calculated start position
	add_child(player)

	# Player Visual (a colored square)
	var player_visual = ColorRect.new()
	player_visual.color = PLAYER_COLOR
	var player_size = Vector2(TILE_SIZE * 0.6, TILE_SIZE * 0.8) # Slightly taller than wide
	player_visual.size = player_size
	player_visual.pivot_offset = player_size / 2.0
	player_visual.position = -player_size / 2.0
	player.add_child(player_visual)

	# Player Collision Shape
	var player_collision_shape = CollisionShape2D.new()
	var player_shape = RectangleShape2D.new()
	player_shape.size = player_size
	player_collision_shape.shape = player_shape
	player.add_child(player_collision_shape)

	# --- Create Goal ---
	goal = Area2D.new()
	goal.name = "Goal"
	goal.global_position = goal_pos # Use the calculated goal position
	add_child(goal)

	# Goal Visual (a colored square)
	var goal_visual = ColorRect.new()
	goal_visual.color = GOAL_COLOR
	var goal_size = Vector2(TILE_SIZE * 0.8, TILE_SIZE * 0.8)
	goal_visual.size = goal_size
	goal_visual.pivot_offset = goal_size / 2.0
	goal_visual.position = -goal_size / 2.0
	goal.add_child(goal_visual)

	# Goal Collision Shape
	var goal_collision_shape = CollisionShape2D.new()
	var goal_shape = RectangleShape2D.new()
	goal_shape.size = goal_size
	goal_collision_shape.shape = goal_shape
	goal.add_child(goal_collision_shape)

	# Connect the signal to detect when a body enters the goal area
	goal.body_entered.connect(_on_goal_body_entered)

	# --- Create UI for Win Message ---
	var canvas_layer = CanvasLayer.new()
	add_child(canvas_layer)

	win_label = Label.new()
	win_label.name = "WinLabel"
	win_label.text = "You Win!"
	win_label.add_theme_color_override("font_color", Color.html("#FFFFFF")) # White text
	win_label.add_theme_color_override("font_shadow_color", Color.html("#000000")) # Black shadow
	win_label.add_theme_constant_override("shadow_offset_x", 2)
	win_label.add_theme_constant_override("shadow_offset_y", 2)
	win_label.add_theme_constant_override("shadow_outline_size", 4) # Thicker shadow outline

	# Attempt to set font size (might rely on default theme or font)
	# A simple way without external resources is scaling
	win_label.set_scale(Vector2(4, 4)) # Scale the label to appear larger

	# Position the label in the center of the viewport
	# Note: Viewport size is only reliable after a frame or two,
	# but for a simple game, positioning in _ready is usually sufficient.
	var viewport_size = get_viewport_rect().size
	win_label.position = viewport_size / 2.0
	win_label.set_horizontal_alignment(HorizontalAlignment.CENTER)
	win_label.set_vertical_alignment(VerticalAlignment.CENTER)
	# Adjust position slightly based on current size after setting text/scale
	# This is an approximation; for perfect centering, use _process or _draw
	# or rely on layout containers. For simplicity here, we'll use a rough offset.
	# A better way is to set pivot and then position, but Label doesn't have pivot like Control nodes.
	# Let's just subtract half the scaled size.
	win_label.position -= win_label.get_size() * win_label.get_scale() / 2.0

	win_label.visible = false # Hide the label initially
	canvas_layer.add_child(win_label)

	# --- Add Camera ---
	var camera = Camera2D.new()
	# Make the camera a child of the player to follow it
	player.add_child(camera)
	# Optional: Set camera limits based on level size
	# camera.limit_left = 0
	# camera.limit_right = LEVEL_GRID[0].size() * TILE_SIZE
	# camera.limit_top = 0
	# camera.limit_bottom = LEVEL_GRID.size() * TILE_SIZE
	# camera.limit_smoothed = true # Smooth camera movement
	# camera.position_smoothing_speed = 5.0 # Adjust smoothing speed


# --- Physics Process ---
# Called every physics frame. Handles movement and collisions.
func _physics_process(delta: float) -> void:
	# Stop processing movement if the game is won
	if game_won:
		player.velocity.x = 0 # Stop horizontal movement
		# Apply gravity even when won, so player falls if off edge
		player.velocity.y += GRAVITY * delta
		player.move_and_slide()
		return # Stop processing input and movement

	# --- Apply Gravity ---
	# Add gravity to the player's vertical velocity
	if not player.is_on_floor():
		player.velocity.y += GRAVITY * delta

	# --- Handle Input ---
	# Get horizontal input (-1 for left, 1 for right, 0 for none)
	var input_axis: float = Input.get_axis("move_left", "move_right")

	# Set horizontal velocity based on input
	player.velocity.x = input_axis * PLAYER_SPEED

	# Handle jump input
	# Check if the jump action is just pressed AND the player is on the floor
	if Input.is_action_just_pressed("jump") and player.is_on_floor():
		player.velocity.y = JUMP_VELOCITY

	# --- Move and Slide ---
	# Move the player and handle collisions with platforms
	player.move_and_slide()


# --- Signal Handlers ---
# Called when a body enters the goal area
func _on_goal_body_entered(body: Node) -> void:
	# Check if the body that entered is the player node
	# Comparing node references is reliable
	if body == player:
		win_game()


# --- Game Logic Functions ---
# Handles actions needed when the player wins
func win_game() -> void:
	if not game_won: # Only trigger win logic once
		game_won = true
		win_label.visible = true
		# Optionally stop player horizontal movement immediately
		player.velocity.x = 0
		print("You Win!") # Print to console for debugging


# --- Helper Function to Create Platform Tiles ---
# Creates a StaticBody2D with visual and collision shape for a platform segment
func create_platform_tile(position: Vector2, parent_node: Node2D) -> void:
	var platform = StaticBody2D.new()
	# Set the global position of the platform tile (top-left corner)
	platform.global_position = position
	platform.name = "Platform" # Optional: Name nodes for easier debugging
	parent_node.add_child(platform)

	# Platform Visual (a colored square)
	var platform_visual = ColorRect.new()
	platform_visual.color = PLATFORM_COLOR
	platform_visual.size = Vector2(TILE_SIZE, TILE_SIZE)
	platform_visual.position = Vector2.ZERO # Visual is at the StaticBody2D's origin (its top-left)
	platform.add_child(platform_visual)

	# Platform Collision Shape
	var platform_collision_shape = CollisionShape2D.new()
	var platform_shape = RectangleShape2D.new()
	platform_shape.size = Vector2(TILE_SIZE, TILE_SIZE)
	# Collision shape origin is centered by default. Offset it by half its size
	# to align with the StaticBody2D's top-left origin.
	platform_collision_shape.position = Vector2(TILE_SIZE / 2.0, TILE_SIZE / 2.0)
	platform_collision_shape.shape = platform_shape
	platform.add_child(platform_collision_shape)

"""

[node name="Main" type="Node2D"]
script = SubResource("GDScript_main")
