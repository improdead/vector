@tool
extends Node

# Scene Generator
# Creates and modifies scenes with AI-generated code

# Read the current main.tscn file
func read_current_scene():
	var scene_path = "res://main.tscn"

	if FileAccess.file_exists(scene_path):
		var file = FileAccess.open(scene_path, FileAccess.READ)
		var content = file.get_as_text()
		file.close()
		return content

	return ""

# Create a scene with the given code
func create_scene_with_code(code):
	# Get the scene paths - try both resource path and absolute path
	var scene_path = "res://main.tscn"
	var project_dir = ProjectSettings.globalize_path("res://")
	var abs_scene_path = project_dir + "main.tscn"

	print("Creating scene with code")
	print("Resource path: " + scene_path)
	print("Absolute path: " + abs_scene_path)

	# Clean up the code to ensure proper formatting
	code = clean_code(code)
	print("Code cleaned, length: " + str(code.length()))

	# Create the scene content with embedded script
	var scene_content = """[gd_scene load_steps=2 format=3]

[sub_resource type="GDScript" id="GDScript_main"]
script/source = \"\"\"
# Generated by Vector AI
""" + code + """
\"\"\"

[node name="Main" type="Node2D"]
script = SubResource("GDScript_main")
"""
	print("Scene content created, length: " + str(scene_content.length()))

	# Try to create or update the scene file using resource path
	var result = create_scene(scene_path, scene_content)

	# If that fails, try using the absolute path
	if not result.success:
		print("Failed to write using resource path, trying absolute path...")
		result = create_scene(abs_scene_path, scene_content)

		# If that also fails, try using OS.execute to write the file
		if not result.success:
			print("Failed to write using absolute path, trying OS.execute...")
			result = create_scene_with_os_execute(abs_scene_path, scene_content)

			# If that also fails, try writing to a different file
			if not result.success:
				print("Failed to write using OS.execute, trying alternative file...")
				result = create_scene(project_dir + "vector_ai_generated.tscn", scene_content)

				# If that also fails, try using OS.execute with the alternative file
				if not result.success:
					print("Failed to write alternative file, trying OS.execute with alternative file...")
					result = create_scene_with_os_execute(project_dir + "vector_ai_generated.tscn", scene_content)

	print("Scene creation result: " + str(result.success) + " - " + result.message)
	return result

# Create a scene file using OS.execute
func create_scene_with_os_execute(path, content):
	print("Attempting to write file using OS.execute: " + path)

	# Create a temporary file with the content
	var temp_path = OS.get_executable_path().get_base_dir() + "/temp_scene.txt"
	var file = FileAccess.open(temp_path, FileAccess.WRITE)
	if file == null:
		print("Failed to create temporary file")
		return {
			"success": false,
			"message": "Failed to create temporary file"
		}

	file.store_string(content)
	file.close()

	print("Temporary file created at: " + temp_path)

	# Use PowerShell to copy the file
	var output = []
	var ps_command = "Copy-Item -Path '" + temp_path + "' -Destination '" + path + "' -Force"
	print("PowerShell command: " + ps_command)

	var exit_code = OS.execute("powershell", ["-Command", ps_command], output)

	print("PowerShell exit code: " + str(exit_code))
	print("PowerShell output: " + str(output))

	if exit_code != 0:
		return {
			"success": false,
			"message": "Failed to copy file using PowerShell: " + str(output)
		}

	print("File copied successfully using PowerShell!")

	return {
		"success": true,
		"message": "Scene created successfully at " + path + " using PowerShell"
	}

# Clean up the code to ensure proper formatting
func clean_code(code):
	print("Cleaning code...")

	# Remove any duplicate 'extends' statements
	var lines = code.split("\n")
	var cleaned_lines = []
	var found_extends = false

	for line in lines:
		var trimmed = line.strip_edges()

		# Check if this is an 'extends' line
		if trimmed.begins_with("extends"):
			# If we've already found an 'extends' statement, skip this line
			if found_extends:
				print("Skipping duplicate extends statement: " + trimmed)
				continue

			# Otherwise, mark that we've found one and keep it
			found_extends = true

		# Add the line to our cleaned lines
		cleaned_lines.append(line)

	# Rejoin the lines
	code = "\n".join(cleaned_lines)

	# Make sure the code starts with 'extends'
	if not code.strip_edges().begins_with("extends"):
		print("Adding missing extends statement")
		code = "extends Node2D\n\n" + code

	# Make sure there's a newline at the end
	if not code.ends_with("\n"):
		code += "\n"

	print("Code cleaning complete")
	return code

# Create or update a scene file
func create_scene(path, content):
	print("Attempting to write to file: " + path)

	# Check if the directory exists
	var dir_path = path.get_base_dir()
	print("Directory path: " + dir_path)

	if not DirAccess.dir_exists_absolute(dir_path):
		print("Directory does not exist, creating it...")
		var dir_error = DirAccess.make_dir_recursive_absolute(dir_path)
		if dir_error != OK:
			print("Failed to create directory: " + str(dir_error))
			return {
				"success": false,
				"message": "Failed to create directory: " + str(dir_error)
			}

	# Try to create or update the file
	print("Opening file for writing...")
	var file = FileAccess.open(path, FileAccess.WRITE)
	if file == null:
		var error = FileAccess.get_open_error()
		print("Failed to open file for writing: " + str(error))
		return {
			"success": false,
			"message": "Failed to open file for writing: " + str(error)
		}

	print("Writing content to file...")
	file.store_string(content)
	file.close()

	# Verify the file was written
	if FileAccess.file_exists(path):
		print("File exists after writing!")

		# Try to read the file back to verify content
		var verify_file = FileAccess.open(path, FileAccess.READ)
		if verify_file != null:
			var verify_content = verify_file.get_as_text()
			verify_file.close()

			if verify_content.length() > 0:
				print("File content verified, length: " + str(verify_content.length()))
			else:
				print("WARNING: File exists but content is empty!")
		else:
			print("WARNING: File exists but cannot be read!")
	else:
		print("WARNING: File does not exist after writing!")
		return {
			"success": false,
			"message": "File does not exist after writing!"
		}

	print("File written successfully!")
	return {
		"success": true,
		"message": "Scene created successfully at " + path
	}
