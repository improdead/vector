@tool
extends Node

# Scene Generator
# Creates and modifies scenes with AI-generated code

# Read the current main.tscn file
func read_current_scene():
	var scene_path = "res://main.tscn"

	if FileAccess.file_exists(scene_path):
		var file = FileAccess.open(scene_path, FileAccess.READ)
		var content = file.get_as_text()
		file.close()

		if content.strip_edges().is_empty():
			print("Scene file is empty, will create a default scene")
			return create_default_scene()

		return content

	print("Scene file does not exist, will create a default scene")
	return create_default_scene()

# Create a default scene content
func create_default_scene():
	var unique_id = str(randi() % 10000000)
	var uid = "uid://c" + str(randi() % 10000000) + str(randi() % 10000000) + "abc"

	var default_content = """[gd_scene load_steps=2 format=3 uid=\"""" + uid + """\"]

[sub_resource type="GDScript" id="GDScript_""" + unique_id + """"]
script/source = \"\"\"
# Generated by Vector AI
extends Node2D

# Default empty scene
func _ready():
	print(\"Vector AI default scene loaded\")

	# Create a label to show this is a default scene
	var label = Label.new()
	label.text = \"Vector AI - Ready for code generation\"
	label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	label.set_anchors_and_offsets_preset(Control.PRESET_FULL_RECT)

	var canvas_layer = CanvasLayer.new()
	canvas_layer.add_child(label)
	add_child(canvas_layer)
\"\"\"

[node name="Main" type="Node2D"]
script = SubResource("GDScript_""" + unique_id + """")
"""
	return default_content

# Create a scene with the given code - simplified approach
func create_scene_with_code(code):
	print("Creating scene with code - using simplified approach")

	# Get the scene path
	var scene_path = "res://main.tscn"
	var project_dir = ProjectSettings.globalize_path("res://")
	var abs_scene_path = project_dir + "main.tscn"

	print("Target scene path: " + abs_scene_path)

	# Clean up the code to ensure proper formatting
	code = clean_code(code)
	print("Code cleaned, length: " + str(code.length()))

	# Create a unique ID for the scene and script
	var unique_id = str(randi() % 10000000)
	var uid = "uid://c" + str(randi() % 10000000) + str(randi() % 10000000) + "abc"

	# Ensure the code is properly escaped for embedding in the scene file
	# Double quotes need to be escaped in the script/source section
	var escaped_code = code.replace("\"", "\\\"")

	# Create the scene content with embedded script
	var scene_content = """[gd_scene load_steps=2 format=3 uid=\"""" + uid + """\"]

[sub_resource type="GDScript" id="GDScript_""" + unique_id + """"]
script/source = \"\"\"
# Generated by Vector AI
""" + escaped_code + """
\"\"\"

[node name="Main" type="Node2D"]
script = SubResource("GDScript_""" + unique_id + """")
"""
	print("Scene content created, length: " + str(scene_content.length()))

	# Create a backup copy first
	var backup_path = project_dir + "vector_ai_generated.tscn"
	var backup_file = FileAccess.open(backup_path, FileAccess.WRITE)
	if backup_file != null:
		backup_file.store_string(scene_content)
		backup_file.close()
		print("Backup file created at: " + backup_path)

	# DIRECT APPROACH: Write directly to the main.tscn file
	print("Writing directly to main.tscn...")
	var main_file = FileAccess.open(abs_scene_path, FileAccess.WRITE)
	if main_file == null:
		var error = FileAccess.get_open_error()
		print("Failed to open main.tscn for writing: " + str(error))
		return {
			"success": false,
			"message": "Failed to write to main.tscn: " + str(error),
			"backup_path": backup_path
		}

	main_file.store_string(scene_content)
	main_file.close()
	print("main.tscn directly updated")

	# Verify the file was written correctly
	if FileAccess.file_exists(abs_scene_path):
		var verify_file = FileAccess.open(abs_scene_path, FileAccess.READ)
		if verify_file != null:
			var content = verify_file.get_as_text()
			verify_file.close()

			if content.length() > 0:
				print("File content verified, length: " + str(content.length()))
			else:
				print("WARNING: File exists but content is empty!")
				return {
					"success": false,
					"message": "File exists but content is empty!",
					"backup_path": backup_path
				}
		else:
			print("WARNING: File exists but cannot be read!")
			return {
				"success": false,
				"message": "File exists but cannot be read!",
				"backup_path": backup_path
			}
	else:
		print("WARNING: File does not exist after writing!")
		return {
			"success": false,
			"message": "File does not exist after writing!",
			"backup_path": backup_path
		}

	# Try to notify Godot about the file change
	print("Notifying Godot about file change...")
	var result = {
		"success": true,
		"message": "Scene created successfully at " + abs_scene_path,
		"backup_path": backup_path
	}

	# Try to use EditorInterface to reload the scene if available
	var plugin = get_plugin_instance()
	if plugin and plugin.has_method("get_editor_interface"):
		var editor_interface = plugin.get_editor_interface()
		if editor_interface:
			print("Using EditorInterface to reload scene...")
			editor_interface.reload_scene_from_path(scene_path)

			# Also try to get the FileSystem and scan
			var filesystem = editor_interface.get_resource_filesystem()
			if filesystem:
				print("Scanning filesystem...")
				filesystem.scan()
				filesystem.scan_sources()
		else:
			print("EditorInterface not available")
	else:
		print("Plugin instance not available or doesn't have get_editor_interface method")

	print("Scene creation completed successfully")
	return result

# Create a scene file using PowerShell directly
func create_scene_with_powershell(path, content):
	print("Attempting to write file directly using PowerShell: " + path)

	# Create a temporary file with the content
	var temp_dir = OS.get_executable_path().get_base_dir()
	var temp_path = temp_dir + "/temp_scene.txt"
	var temp_path_random = temp_dir + "/temp_scene_" + str(randi()) + ".txt"

	# Write content to temporary file
	var file = FileAccess.open(temp_path, FileAccess.WRITE)
	if file == null:
		print("Failed to create temporary file")
		return {
			"success": false,
			"message": "Failed to create temporary file"
		}

	file.store_string(content)
	file.close()

	print("Temporary file created at: " + temp_path)

	# First try: Use PowerShell to write the file with Out-File (better for large files)
	var output = []
	var ps_command = "Get-Content -Path '" + temp_path + "' -Raw | Out-File -FilePath '" + path + "' -Encoding utf8 -Force"
	print("PowerShell command: " + ps_command)

	var exit_code = OS.execute("powershell", ["-Command", ps_command], output)

	print("PowerShell exit code: " + str(exit_code))
	print("PowerShell output: " + str(output))

	if exit_code != 0:
		# Try alternative approach with Copy-Item
		print("First method failed, trying Copy-Item...")

		# Create a second temporary file with a different name
		var file2 = FileAccess.open(temp_path_random, FileAccess.WRITE)
		if file2 != null:
			file2.store_string(content)
			file2.close()

			# Use Copy-Item which might work better in some cases
			var output2 = []
			var ps_command2 = "Copy-Item -Path '" + temp_path_random + "' -Destination '" + path + "' -Force"

			var exit_code2 = OS.execute("powershell", ["-Command", ps_command2], output2)

			if exit_code2 != 0:
				return {
					"success": false,
					"message": "Failed to write file using both PowerShell methods: " + str(output) + " and " + str(output2)
				}
		else:
			return {
				"success": false,
				"message": "Failed to write file using PowerShell: " + str(output)
			}

	print("File written successfully using PowerShell!")

	# Verify the file was written
	var verify_output = []
	var verify_command = "Test-Path -Path '" + path + "'"
	var verify_exit_code = OS.execute("powershell", ["-Command", verify_command], verify_output)

	if verify_exit_code == 0 and verify_output.size() > 0 and verify_output[0].strip_edges() == "True":
		print("File existence verified with PowerShell!")

		# Also try to verify the content length
		var content_verify_output = []
		var content_verify_command = "(Get-Content -Path '" + path + "' -Raw).Length"
		var content_verify_exit_code = OS.execute("powershell", ["-Command", content_verify_command], content_verify_output)

		if content_verify_exit_code == 0 and content_verify_output.size() > 0:
			print("File content length verified: " + content_verify_output[0].strip_edges())
	else:
		print("WARNING: File existence could not be verified with PowerShell!")
		return {
			"success": false,
			"message": "File existence could not be verified with PowerShell"
		}

	# Try to force Godot to detect the change by modifying the file timestamp
	var timestamp_output = []
	var timestamp_command = "(Get-Item -Path '" + path + "').LastWriteTime = Get-Date"
	OS.execute("powershell", ["-Command", timestamp_command], timestamp_output)
	print("File timestamp updated to force detection")

	return {
		"success": true,
		"message": "Scene created successfully at " + path + " using PowerShell"
	}

# Create a scene file using OS.execute
func create_scene_with_os_execute(path, content):
	print("Attempting to write file using OS.execute: " + path)

	# Create a temporary file with the content
	var temp_path = OS.get_executable_path().get_base_dir() + "/temp_scene.txt"
	var file = FileAccess.open(temp_path, FileAccess.WRITE)
	if file == null:
		print("Failed to create temporary file")
		return {
			"success": false,
			"message": "Failed to create temporary file"
		}

	file.store_string(content)
	file.close()

	print("Temporary file created at: " + temp_path)

	# Use PowerShell to copy the file
	var output = []
	var ps_command = "Copy-Item -Path '" + temp_path + "' -Destination '" + path + "' -Force"
	print("PowerShell command: " + ps_command)

	var exit_code = OS.execute("powershell", ["-Command", ps_command], output)

	print("PowerShell exit code: " + str(exit_code))
	print("PowerShell output: " + str(output))

	if exit_code != 0:
		return {
			"success": false,
			"message": "Failed to copy file using PowerShell: " + str(output)
		}

	print("File copied successfully using PowerShell!")

	return {
		"success": true,
		"message": "Scene created successfully at " + path + " using PowerShell"
	}

# Clean up the code to ensure proper formatting and fix common syntax issues
func clean_code(code):
	print("Cleaning code...")

	# Remove any duplicate 'extends' statements
	var lines = code.split("\n")
	var cleaned_lines = []
	var found_extends = false
	var in_function = false
	var in_class = false
	var current_indent = ""
	var last_line_empty = false
	var consecutive_empty_lines = 0

	for line in lines:
		var trimmed = line.strip_edges()

		# Skip excessive empty lines (limit to max 2 consecutive empty lines)
		if trimmed.is_empty():
			consecutive_empty_lines += 1
			if consecutive_empty_lines > 2:
				continue
			last_line_empty = true
		else:
			consecutive_empty_lines = 0
			last_line_empty = false

		# Check if this is an 'extends' line
		if trimmed.begins_with("extends"):
			# If we've already found an 'extends' statement, skip this line
			if found_extends:
				print("Skipping duplicate extends statement: " + trimmed)
				continue

			# Otherwise, mark that we've found one and keep it
			found_extends = true

		# Track function and class scope for proper indentation
		if trimmed.begins_with("func ") and trimmed.ends_with(":"):
			in_function = true
			current_indent = "	" # One tab for function body
		elif trimmed.begins_with("class ") and trimmed.ends_with(":"):
			in_class = true
			current_indent = "	" # One tab for class body
		elif in_function and trimmed.is_empty():
			# Keep track of empty lines in functions
			pass
		elif in_function and not line.begins_with("	"):
			# Line doesn't start with a tab, we're likely out of the function
			in_function = false
			current_indent = ""
		elif in_class and not line.begins_with("	"):
			# Line doesn't start with a tab, we're likely out of the class
			in_class = false
			current_indent = ""

		# Add the line to our cleaned lines
		cleaned_lines.append(line)

	# Rejoin the lines
	code = "\n".join(cleaned_lines)

	# Make sure the code starts with 'extends' but don't add it if it already exists
	if not code.strip_edges().begins_with("extends") and not "extends Node2D" in code:
		print("Adding missing extends statement")
		code = "extends Node2D\n\n" + code

	# Fix common syntax issues
	code = fix_variable_declarations(code)
	code = fix_missing_semicolons(code)
	code = fix_function_declarations(code)
	code = fix_array_declarations(code)
	code = fix_vector_declarations(code)

	# Make sure there's a newline at the end
	if not code.ends_with("\n"):
		code += "\n"

	print("Code cleaning complete")
	return code

# Fix array declarations with extra semicolons
func fix_array_declarations(code):
	print("Fixing array declarations...")

	# Fix array declarations with semicolons after opening bracket
	code = code.replace("= [;", "= [")

	# Fix array items with trailing semicolons
	var lines = code.split("\n")
	var in_array = false
	var fixed_lines = []

	for i in range(lines.size()):
		var line = lines[i]
		var trimmed = line.strip_edges()

		# Check if we're entering an array declaration
		if "= [" in line and not line.ends_with("]"):
			in_array = true

		# If we're in an array, check for trailing semicolons on array items
		if in_array:
			# Check if this line has a trailing semicolon that's not part of a string
			if trimmed.ends_with(",;"):
				line = line.replace(",;", ",")
				print("Removed extra semicolon from array item")
			elif trimmed.ends_with(";") and not trimmed.ends_with("\";") and not trimmed.ends_with("';"):
				line = line.substr(0, line.length() - 1)
				print("Removed trailing semicolon from array item")

			# Check if we're exiting the array
			if trimmed.ends_with("];"):
				line = line.replace("];", "]")
				print("Removed extra semicolon after array closing bracket")
				in_array = false
			elif trimmed.ends_with("]"):
				in_array = false

		fixed_lines.append(line)

	return "\n".join(fixed_lines)

# Fix Vector2 declarations with extra semicolons
func fix_vector_declarations(code):
	print("Fixing Vector2 declarations...")

	# Fix Vector2 declarations with semicolons after opening parenthesis
	code = code.replace("Vector2(;", "Vector2(")

	# Fix Vector2 parameters with trailing semicolons
	var lines = code.split("\n")
	var in_vector = false
	var vector_indent = ""
	var fixed_lines = []

	for i in range(lines.size()):
		var line = lines[i]
		var trimmed = line.strip_edges()

		# Check if we're entering a Vector2 declaration
		if "Vector2(" in line and not line.ends_with(")") and not line.ends_with(");"):
			in_vector = true
			vector_indent = line.substr(0, line.find("Vector2("))

		# If we're in a Vector2, check for trailing semicolons on parameters
		if in_vector:
			# Check if this line has a trailing semicolon that's not part of a string
			if trimmed.ends_with(",;"):
				line = line.replace(",;", ",")
				print("Removed extra semicolon from Vector2 parameter")
			elif trimmed.ends_with(";") and not trimmed.ends_with("\";") and not trimmed.ends_with("';"):
				line = line.substr(0, line.length() - 1)
				print("Removed trailing semicolon from Vector2 parameter")

			# Check if we're exiting the Vector2
			if trimmed.ends_with(");"):
				line = line.replace(");", ")")
				print("Removed extra semicolon after Vector2 closing parenthesis")
				in_vector = false
			elif trimmed.ends_with(")"):
				in_vector = false

		fixed_lines.append(line)

	# Now join the lines and fix any multi-line Vector2 declarations
	code = "\n".join(fixed_lines)

	# Replace multi-line Vector2 declarations with single-line ones
	var pattern = "Vector2\\([^)]*\\)"
	var regex = RegEx.new()
	regex.compile(pattern)

	var matches = regex.search_all(code)
	for match_result in matches:
		var matched_text = match_result.get_string()
		if "\n" in matched_text:
			var fixed_text = matched_text.replace("\n", " ").replace(";", "")
			code = code.replace(matched_text, fixed_text)
			print("Fixed multi-line Vector2 declaration")

	return code

# Fix variable declarations that might be missing 'var' or 'const'
func fix_variable_declarations(code):
	var lines = code.split("\n")
	var fixed_lines = []
	var in_function = false
	var in_class_def = false

	for i in range(lines.size()):
		var line = lines[i]
		var trimmed = line.strip_edges()

		# Track if we're in a function or class definition
		if trimmed.begins_with("func ") and trimmed.ends_with(":"):
			in_function = true
		elif trimmed.begins_with("class ") and trimmed.ends_with(":"):
			in_class_def = true
		elif in_function and trimmed.is_empty():
			# Empty line in function
			pass
		elif in_function and not line.begins_with("	"):
			# Line doesn't start with a tab, we're out of the function
			in_function = false
		elif in_class_def and not line.begins_with("	"):
			# Line doesn't start with a tab, we're out of the class definition
			in_class_def = false

		# Only check for variable declarations outside of functions and class definitions
		if not in_function and not in_class_def:
			# Check for variable assignments without var/const at the top level
			if "=" in trimmed and not trimmed.begins_with("#") and not trimmed.begins_with("var ") and not trimmed.begins_with("const ") and not trimmed.begins_with("@export"):
				# This looks like a variable assignment without var/const
				# Check if it's not part of a control structure
				if not (trimmed.begins_with("if ") or trimmed.begins_with("elif ") or trimmed.begins_with("else") or
						trimmed.begins_with("for ") or trimmed.begins_with("while ") or trimmed.begins_with("match ")):
					# It's likely a variable declaration missing 'var'
					var indent = ""
					for j in range(line.length()):
						if line[j] == " " or line[j] == "\t":
							indent += line[j]
						else:
							break

					print("Adding missing 'var' to variable declaration: " + trimmed)
					line = indent + "var " + trimmed

		fixed_lines.append(line)

	return "\n".join(fixed_lines)

# Fix missing semicolons in expressions
func fix_missing_semicolons(code):
	# This is a simplified approach - a full parser would be better
	var lines = code.split("\n")
	var fixed_lines = []

	for i in range(lines.size()):
		var line = lines[i]
		var trimmed = line.strip_edges()

		# Skip comments and empty lines
		if trimmed.begins_with("#") or trimmed.is_empty():
			fixed_lines.append(line)
			continue

		# Skip lines that already end with a semicolon or are control structures
		if (trimmed.ends_with(";") or trimmed.ends_with(":") or trimmed.begins_with("func ") or
		   trimmed.begins_with("class ") or trimmed.begins_with("if ") or trimmed.begins_with("elif ") or
		   trimmed.begins_with("else") or trimmed.begins_with("for ") or trimmed.begins_with("while ") or
		   trimmed.begins_with("match ")):
			fixed_lines.append(line)
			continue

		# Add semicolon to expression statements that need it
		if "=" in trimmed or trimmed.begins_with("return ") or trimmed.find(".") > 0:
			if not trimmed.ends_with(";"):
				line += ";"
				print("Adding missing semicolon to: " + trimmed)

		fixed_lines.append(line)

	return "\n".join(fixed_lines)

# Fix function declarations
func fix_function_declarations(code):
	var lines = code.split("\n")
	var fixed_lines = []

	for i in range(lines.size()):
		var line = lines[i]
		var trimmed = line.strip_edges()

		# Fix function declarations without proper colon
		if trimmed.begins_with("func ") and not trimmed.ends_with(":"):
			line += ":"
			print("Adding missing colon to function declaration: " + trimmed)

		fixed_lines.append(line)

	return "\n".join(fixed_lines)

# Create or update a scene file
func create_scene(path, content):
	print("Attempting to write to file: " + path)

	# Check if the directory exists
	var dir_path = path.get_base_dir()
	print("Directory path: " + dir_path)

	if not DirAccess.dir_exists_absolute(dir_path):
		print("Directory does not exist, creating it...")
		var dir_error = DirAccess.make_dir_recursive_absolute(dir_path)
		if dir_error != OK:
			print("Failed to create directory: " + str(dir_error))
			return {
				"success": false,
				"message": "Failed to create directory: " + str(dir_error)
			}

	# Try to create or update the file
	print("Opening file for writing...")
	var file = FileAccess.open(path, FileAccess.WRITE)
	if file == null:
		var error = FileAccess.get_open_error()
		print("Failed to open file for writing: " + str(error))
		return {
			"success": false,
			"message": "Failed to open file for writing: " + str(error)
		}

	print("Writing content to file...")
	file.store_string(content)
	file.close()

	# Verify the file was written
	if FileAccess.file_exists(path):
		print("File exists after writing!")

		# Try to read the file back to verify content
		var verify_file = FileAccess.open(path, FileAccess.READ)
		if verify_file != null:
			var verify_content = verify_file.get_as_text()
			verify_file.close()

			if verify_content.length() > 0:
				print("File content verified, length: " + str(verify_content.length()))
			else:
				print("WARNING: File exists but content is empty!")
		else:
			print("WARNING: File exists but cannot be read!")
	else:
		print("WARNING: File does not exist after writing!")
		return {
			"success": false,
			"message": "File does not exist after writing!"
		}

	print("File written successfully!")
	return {
		"success": true,
		"message": "Scene created successfully at " + path
	}

# Ensure Godot reloads the scene file
func ensure_godot_reloads_scene(path):
	print("Ensuring Godot reloads the scene...")

	# Method 1: Try using EditorInterface
	var result = try_editor_interface_reload(path)
	if result.success:
		return result

	# Method 2: Try using ResourceLoader
	result = try_resource_loader_reload(path)
	if result.success:
		return result

	# Method 3: Try modifying the file timestamp
	result = try_timestamp_modification(path)
	if result.success:
		return result

	# All methods failed
	return {
		"success": false,
		"message": "Failed to ensure Godot reloads the scene. Please try manually reloading the scene in the editor."
	}

# Try using EditorInterface to reload the scene
func try_editor_interface_reload(path):
	print("Trying EditorInterface reload...")

	# Get the plugin instance
	var plugin = get_plugin_instance()
	if not plugin:
		return {
			"success": false,
			"message": "Cannot access EditorInterface (no plugin instance)"
		}

	# Try to get the EditorInterface
	var editor_interface = plugin.get_editor_interface()
	if not editor_interface:
		return {
			"success": false,
			"message": "Cannot access EditorInterface"
		}

	# Try to reload the scene
	print("Calling reload_scene_from_path with: " + path)
	editor_interface.reload_scene_from_path(path)

	# Also try to get the FileSystem and scan
	var filesystem = editor_interface.get_resource_filesystem()
	if filesystem:
		print("Scanning filesystem...")
		filesystem.scan()
		filesystem.scan_sources()

	return {
		"success": true,
		"message": "Attempted to reload scene using EditorInterface"
	}

# Try using ResourceLoader to reload the scene
func try_resource_loader_reload(path):
	print("Trying ResourceLoader reload...")

	# Convert absolute path to resource path if needed
	var resource_path = path
	if not path.begins_with("res://"):
		# Try to convert to resource path
		var project_dir = ProjectSettings.globalize_path("res://")
		if path.begins_with(project_dir):
			resource_path = "res://" + path.substr(project_dir.length())
		else:
			print("Cannot convert absolute path to resource path: " + path)
			return {
				"success": false,
				"message": "Cannot convert absolute path to resource path"
			}

	# Try to reload the resource
	print("Reloading resource: " + resource_path)
	if ResourceLoader.has_cached(resource_path):
		ResourceLoader.load(resource_path, "", ResourceLoader.CACHE_MODE_REPLACE)
		print("Resource reloaded")
		return {
			"success": true,
			"message": "Resource reloaded using ResourceLoader"
		}
	else:
		print("Resource not cached, loading for the first time")
		var resource = ResourceLoader.load(resource_path)
		if resource:
			print("Resource loaded successfully")
			return {
				"success": true,
				"message": "Resource loaded using ResourceLoader"
			}
		else:
			print("Failed to load resource")
			return {
				"success": false,
				"message": "Failed to load resource using ResourceLoader"
			}

# Try modifying the file timestamp to force Godot to detect the change
func try_timestamp_modification(path):
	print("Trying timestamp modification...")

	# Method 1: Use PowerShell to touch the file (update its timestamp)
	var output = []
	var ps_command = "(Get-Item -Path '" + path + "').LastWriteTime = Get-Date"

	var exit_code = OS.execute("powershell", ["-Command", ps_command], output)

	if exit_code != 0:
		print("Failed to update file timestamp with PowerShell: " + str(output))
	else:
		print("File timestamp updated with PowerShell")

	# Method 2: Try to create a small temporary change to force detection
	# This is a more aggressive approach that should definitely trigger a reload
	var resource_path = path
	if not path.begins_with("res://"):
		# Try to convert to resource path
		var project_dir = ProjectSettings.globalize_path("res://")
		if path.begins_with(project_dir):
			resource_path = "res://" + path.substr(project_dir.length())

	# Read the current content
	var current_content = ""
	if FileAccess.file_exists(path):
		var file = FileAccess.open(path, FileAccess.READ)
		if file != null:
			current_content = file.get_as_text()
			file.close()

	if not current_content.is_empty():
		# Add a tiny whitespace change that won't affect functionality
		# but will force Godot to detect the change
		var modified_content = current_content
		if not modified_content.ends_with("\n\n"):
			modified_content += "\n"

		# Write it back
		var file = FileAccess.open(path, FileAccess.WRITE)
		if file != null:
			file.store_string(modified_content)
			file.close()
			print("Added small change to force file reload detection")

	# Method 3: Try to force a resource reimport
	if ResourceLoader.has_cached(resource_path):
		ResourceLoader.load(resource_path, "", ResourceLoader.CACHE_MODE_REPLACE)
		print("Resource cache replaced")

	return {
		"success": true,
		"message": "Multiple methods used to force file reload detection"
	}

# Helper function to get the plugin instance
func get_plugin_instance():
	# This assumes the script has a way to access the plugin instance
	# It might be passed in or accessible through a parent node
	var parent = get_parent()
	while parent:
		if parent.has_method("get_editor_interface"):
			return parent

		# Check if parent has a plugin property using get() which is safer than has_property
		if parent.get("plugin") != null:
			return parent.plugin

		parent = parent.get_parent()

	return null
