@tool
extends Node

# Scene Generator
# Creates and modifies scenes with AI-generated code

# Read the current main.tscn file
func read_current_scene():
	var scene_path = "res://main.tscn"

	if FileAccess.file_exists(scene_path):
		var file = FileAccess.open(scene_path, FileAccess.READ)
		var content = file.get_as_text()
		file.close()
		return content

	return ""

# Create a scene with the given code
func create_scene_with_code(code):
	# Get the scene path
	var scene_path = "res://main.tscn"

	# Clean up the code to ensure proper formatting
	code = clean_code(code)

	# Create the scene content with embedded script
	var scene_content = """[gd_scene load_steps=2 format=3]

[sub_resource type="GDScript" id="GDScript_main"]
script/source = \"\"\"
# Generated by Vector AI
""" + code + """
\"\"\"

[node name="Main" type="Node2D"]
script = SubResource("GDScript_main")
"""

	# Create or update the scene file
	var result = create_scene(scene_path, scene_content)

	return result

# Clean up the code to ensure proper formatting
func clean_code(code):
	# Make sure the code starts with 'extends'
	if not code.strip_edges().begins_with("extends"):
		code = "extends Node2D\n\n" + code

	# Make sure there's a newline at the end
	if not code.ends_with("\n"):
		code += "\n"

	# Check for common formatting issues
	var lines = code.split("\n")
	var cleaned_lines = []
	var in_function = false

	for line in lines:
		var trimmed = line.strip_edges()

		# Skip empty lines
		if trimmed.is_empty():
			cleaned_lines.append(line)
			continue

		# Check if we're entering a function
		if trimmed.begins_with("func "):
			in_function = true

		# Check if we're exiting a function
		if in_function and trimmed == "":
			in_function = false

		# Check for variable declarations at class level (not in a function)
		if not in_function and "=" in trimmed and not trimmed.begins_with("#") and not trimmed.begins_with("var ") and not trimmed.begins_with("const "):
			# This looks like a variable assignment without var/const at class level
			line = "var " + line

		cleaned_lines.append(line)

	return "\n".join(cleaned_lines)

# Create or update a scene file
func create_scene(path, content):
	# Check if the directory exists
	var dir_path = path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir_path):
		var dir_error = DirAccess.make_dir_recursive_absolute(dir_path)
		if dir_error != OK:
			return {
				"success": false,
				"message": "Failed to create directory: " + str(dir_error)
			}

	# Create or update the file
	var file = FileAccess.open(path, FileAccess.WRITE)
	if file == null:
		return {
			"success": false,
			"message": "Failed to open file for writing: " + str(FileAccess.get_open_error())
		}

	file.store_string(content)
	file.close()

	return {
		"success": true,
		"message": "Scene created successfully at " + path
	}
