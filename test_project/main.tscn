[gd_scene load_steps=2 format=3]

[sub_resource type="GDScript" id="GDScript_main"]
script/source = """
# Generated by Vector AI
extends Node2D

# --- Constants ---
const TILE_SIZE: int = 64 # Size of each tile (wall block, path segment) in pixels

# Define the maze structure (0 = empty path, 1 = wall, 2 = player start, 3 = goal)
# This is a simple top-down maze grid
const MAZE_GRID: Array[Array[int]] = [
	[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
	[1, 2, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
	[1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1],
	[1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1],
	[1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1],
	[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
	[1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1],
	[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1],
	[1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
	[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 1],
	[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]

const WALL_COLOR: Color = Color.html("#604020") # Brown for walls
const PLAYER_COLOR: Color = Color.html("#4287f5") # Blue for the player
const GOAL_COLOR: Color = Color.html("#00FF00") # Green for the goal
const BACKGROUND_COLOR: Color = Color.html("#87CEEB") # Sky blue background

# --- Variables ---
var player: Node2D # Reference to the player node
var win_label: Label # Reference to the label displaying the win message
var game_won: bool = false # State variable to track if the game is won

# Player's current position in grid coordinates
var player_grid_x: int = -1
var player_grid_y: int = -1

# Goal's position in grid coordinates
var goal_grid_x: int = -1
var goal_grid_y: int = -1

# Flag to prevent multiple moves per key press
var can_move: bool = true

# --- Ready Function ---
# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	# --- Setup Input Actions ---
	# IMPORTANT: For this script to work, you MUST configure input actions
	# in Project Settings -> Input Map. Add the following actions:
	# "move_up" (e.g., Up Arrow, W)
	# "move_down" (e.g., Down Arrow, S)
	# "move_left" (e.g., Left Arrow, A)
	# "move_right" (e.g., Right Arrow, D)
	# If these actions are not set up, the game will not respond to input.

	# --- Set Background Color ---
	# Create a solid background color rect filling the approximate viewport
	var background = ColorRect.new()
	background.color = BACKGROUND_COLOR
	# Set a large size to cover a typical window; ideally this would adapt
	background.size = Vector2(2000, 1200)
	add_child(background)

	# --- Create Maze ---
	# A container for maze wall nodes to keep the scene tree organized
	var maze_container = Node2D.new()
	maze_container.name = "MazeContainer"
	add_child(maze_container)

	# Iterate through the maze grid to create walls, find player start and goal
	for row_index in range(MAZE_GRID.size()):
		for col_index in range(MAZE_GRID[row_index].size()):
			var cell_type = MAZE_GRID[row_index][col_index]
			# Calculate the top-left position of the current grid cell
			var tile_position = Vector2(col_index * TILE_SIZE, row_index * TILE_SIZE)

			match cell_type:
				1: # Wall
					create_wall_tile(tile_position, maze_container)
				2: # Player Start
					player_grid_x = col_index
					player_grid_y = row_index
				3: # Goal
					goal_grid_x = col_index
					goal_grid_y = row_index
				0: # Empty path, do nothing
					pass

	# --- Create Player ---
	player = Node2D.new() # Use Node2D for simple grid movement
	player.name = "Player"
	# Set the player's initial position to the center of the start grid cell
	player.global_position = get_position_from_grid(player_grid_x, player_grid_y)
	add_child(player)

	# Player Visual (a colored square)
	var player_visual = ColorRect.new()
	player_visual.color = PLAYER_COLOR
	# Player size is slightly smaller than a tile to fit within paths
	var player_size = Vector2(TILE_SIZE * 0.8, TILE_SIZE * 0.8)
	player_visual.size = player_size
	# Set pivot to the center for easier positioning relative to Node2D origin
	player_visual.pivot_offset = player_size / 2.0
	# Position the visual so its center aligns with the Node2D origin
	player_visual.position = -player_size / 2.0
	player.add_child(player_visual)

	# --- Create Goal Visual ---
	# We don't need an Area2D for the goal if we check grid position
	var goal_visual_node = Node2D.new()
	goal_visual_node.name = "Goal"
	# Set the goal's position to the center of the goal grid cell
	goal_visual_node.global_position = get_position_from_grid(goal_grid_x, goal_grid_y)
	add_child(goal_visual_node)

	# Goal Visual (a colored square)
	var goal_visual = ColorRect.new()
	goal_visual.color = GOAL_COLOR
	var goal_size = Vector2(TILE_SIZE * 0.8, TILE_SIZE * 0.8) # Slightly smaller than a tile
	goal_visual.size = goal_size
	# Set pivot to the center for easier positioning relative to Node2D origin
	goal_visual.pivot_offset = goal_size / 2.0
	# Position the visual so its center aligns with the Node2D origin
	goal_visual.position = -goal_size / 2.0
	goal_visual_node.add_child(goal_visual)


	# --- Create UI for Win Message ---
	# Use a CanvasLayer to ensure UI elements are drawn on top
	var canvas_layer = CanvasLayer.new()
	add_child(canvas_layer)

	win_label = Label.new()
	win_label.name = "WinLabel"
	win_label.text = "You Win!"
	# Set text color and shadow for visibility
	win_label.add_theme_color_override("font_color", Color.html("#FFFFFF")) # White text
	win_label.add_theme_color_override("font_shadow_color", Color.html("#000000")) # Black shadow
	win_label.add_theme_constant_override("shadow_offset_x", 2)
	win_label.add_theme_constant_override("shadow_offset_y", 2)
	win_label.add_theme_constant_override("shadow_outline_size", 4) # Thicker shadow outline

	# Scale the label to make the default font larger
	win_label.set_scale(Vector2(4, 4))

	# Position the label in the center of the viewport
	# get_viewport_rect().size gives the current viewport dimensions
	var viewport_size = get_viewport_rect().size
	win_label.position = viewport_size / 2.0
	# Set alignment to center the text within the label's bounds
	win_label.set_horizontal_alignment(HorizontalAlignment.CENTER)
	win_label.set_vertical_alignment(VerticalAlignment.CENTER)
	# Adjust the position based on the label's size and scale so its center is at viewport center
	# Note: get_size() here gives the size *before* scaling. We need to adjust by scaled size.
	var scaled_size = win_label.get_size() * win_label.get_scale()
	win_label.position -= scaled_size / 2.0

	win_label.visible = false # Hide the label initially
	canvas_layer.add_child(win_label)

	# --- Add Camera ---
	var camera = Camera2D.new()
	camera.name = "Camera2D"
	add_child(camera)
	# Center the camera on the maze
	var maze_width = MAZE_GRID[0].size() * TILE_SIZE
	var maze_height = MAZE_GRID.size() * TILE_SIZE
	camera.global_position = Vector2(maze_width / 2.0, maze_height / 2.0)
	camera.make_current()
	# Optional: Set zoom if the maze is much smaller/larger than the viewport
	# camera.zoom = Vector2(0.8, 0.8) # Example: zoom out slightly


# --- Process Function ---
# Called every frame. Handles input for tile-based movement.
func _process(delta: float) -> void:
	# Stop processing movement inputs if the game is won
	if game_won:
		return # Exit the function early if the game is won

	# Only allow a move if the previous move input has been released
	if not can_move:
		# Check if any movement key is still pressed. If not, reset can_move.
		if not (Input.is_action_pressed("move_up") or
				Input.is_action_pressed("move_down") or
				Input.is_action_pressed("move_left") or
				Input.is_action_pressed("move_right")):
			can_move = true
		return # Exit if not allowed to move yet

	var move_dir: Vector2 = Vector2.ZERO

	# Check for directional input using is_action_just_pressed for tile-by-tile movement
	if Input.is_action_just_pressed("move_up"):
		move_dir = Vector2.UP
	elif Input.is_action_just_pressed("move_down"):
		move_dir = Vector2.DOWN
	elif Input.is_action_just_pressed("move_left"):
		move_dir = Vector2.LEFT
	elif Input.is_action_just_pressed("move_right"):
		move_dir = Vector2.RIGHT

	# If a direction was pressed
	if move_dir != Vector2.ZERO:
		var next_grid_x = player_grid_x + int(move_dir.x)
		var next_grid_y = player_grid_y + int(move_dir.y)

		# Check if the next grid position is within the maze bounds
		var maze_height = MAZE_GRID.size()
		var maze_width = MAZE_GRID[0].size() if maze_height > 0 else 0

		if next_grid_x >= 0 and next_grid_x < maze_width and \
		   next_grid_y >= 0 and next_grid_y < maze_height:

			# Check if the next grid position is not a wall
			if MAZE_GRID[next_grid_y][next_grid_x] != 1: # 1 represents a wall
				# Update player's grid position
				player_grid_x = next_grid_x
				player_grid_y = next_grid_y

				# Update player's global position to the center of the new grid cell
				player.global_position = get_position_from_grid(player_grid_x, player_grid_y)

				# Check for win condition after moving
				if player_grid_x == goal_grid_x and player_grid_y == goal_grid_y:
					win_game()

				# Prevent moving again until the key is released and pressed again
				can_move = false


# --- Game Logic Functions ---
# Handles actions needed when the player reaches the goal and wins the game.
func win_game() -> void:
	# Check if the game hasn't already been won to prevent triggering multiple times
	if not game_won:
		game_won = true # Set the game state to won
		win_label.visible = true # Make the win message visible
		print("You Win!") # Output a message to the console
		# Optionally disable further input processing (handled at start of _process)


# --- Helper Function to Create Wall Tiles ---
# Creates a StaticBody2D with a visual and collision shape for a single wall segment.
func create_wall_tile(position: Vector2, parent_node: Node2D) -> void:
	# Create the StaticBody2D node which represents the wall's physical presence (for potential future use,
	# but for this simple grid movement, it mainly serves as a visual + position marker)
	var wall = StaticBody2D.new()
	wall.name = "Wall"
	# Set the global position of the wall tile (top-left corner of the tile)
	wall.global_position = position
	parent_node.add_child(wall) # Add the wall node to the specified parent

	# Create the visual representation of the wall (a colored rectangle)
	var wall_visual = ColorRect.new()
	wall_visual.color = WALL_COLOR # Set the color from constants
	wall_visual.size = Vector2(TILE_SIZE, TILE_SIZE) # Set the size to match the tile size
	wall_visual.position = Vector2.ZERO # Position the visual at the StaticBody2D's origin (top-left)
	wall.add_child(wall_visual) # Add the visual as a child of the wall

	# Create the collision shape for the wall. While the player isn't using move_and_slide,
	# having collision shapes here is good practice if physics were added later,
	# or for using methods like `test_move` with CharacterBody2D.
	# For this simple grid check, the collision shape isn't strictly necessary,
	# but we include it as it's typical for walls.
	var wall_collision_shape = CollisionShape2D.new()
	var wall_shape = RectangleShape2D.new()
	wall_shape.size = Vector2(TILE_SIZE, TILE_SIZE) # Set the size of the collision shape
	wall_collision_shape.shape = wall_shape # Assign the shape to the CollisionShape2D
	# Position the CollisionShape2D at the center of the tile relative to the parent's origin
	wall_collision_shape.position = Vector2(TILE_SIZE / 2.0, TILE_SIZE / 2.0)
	wall.add_child(wall_collision_shape) # Add the collision shape as a child of the wall

# --- Helper Function to convert grid coordinates to global position ---
func get_position_from_grid(grid_x: int, grid_y: int) -> Vector2:
	# Calculate the global position for the center of the grid cell
	return Vector2(grid_x * TILE_SIZE + TILE_SIZE / 2.0, grid_y * TILE_SIZE + TILE_SIZE / 2.0)

"""

[node name="Main" type="Node2D"]
script = SubResource("GDScript_main")


