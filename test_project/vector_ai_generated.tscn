[gd_scene load_steps=2 format=3 uid="uid://c81396346744056abc"]

[sub_resource type="GDScript" id="GDScript_2462143"]
script/source = """
# Generated by Vector AI
extends Node2D

# Constants for game parameters
const TILE_SIZE = 32; # Size of each tile in pixels;
const MAZE_WIDTH = 15; # Number of horizontal cells in the maze grid (affects complexity);
const MAZE_HEIGHT = 10; # Number of vertical cells in the maze grid (affects complexity);
const WALL_TILE = 0; # Identifier for wall cells in the grid;
const FLOOR_TILE = 1; # Identifier for floor cells in the grid;

const PLAYER_SPEED = 200; # Movement speed of the player;

# Variables to hold game nodes
var tile_map: TileMap;
var player: CharacterBody2D;
var goal_area: Area2D;
var win_label: Label;

# 2D array representing the maze layout.
# The size will be (MAZE_WIDTH * 2 + 1) x (MAZE_HEIGHT * 2 + 1)
# to accommodate walls between passages.
var maze_grid = []

# Initialize the maze grid with walls
func _initialize_maze_grid():
	# Create a grid filled with walls
	var width = MAZE_WIDTH * 2 + 1
	var height = MAZE_HEIGHT * 2 + 1
	
	# Initialize the 2D array
	maze_grid = []
	for x in range(width):
		maze_grid.append([])
		for y in range(height):
			maze_grid[x].append(WALL_TILE)

# Generate the maze using recursive backtracking algorithm
func _generate_maze(x, y):
	# Mark the current cell as a floor
	maze_grid[x][y] = FLOOR_TILE
	
	# Define the four possible directions (right, down, left, up)
	var directions = [Vector2i(2, 0), Vector2i(0, 2), Vector2i(-2, 0), Vector2i(0, -2)]
	# Shuffle the directions for randomness
	directions.shuffle()
	
	# Try each direction
	for dir in directions:
		var nx = x + dir.x
		var ny = y + dir.y
		
		# Check if the new position is within bounds and is a wall
		if nx > 0 and nx < MAZE_WIDTH * 2 and ny > 0 and ny < MAZE_HEIGHT * 2 and maze_grid[nx][ny] == WALL_TILE:
			# Carve a path by making the wall between current and new position a floor
			maze_grid[x + dir.x / 2][y + dir.y / 2] = FLOOR_TILE
			# Recursively continue from the new position
			_generate_maze(nx, ny)

func _ready():
	# Ensure random number generator is seeded
	randomize();

	# Initialize the maze grid with walls
	_initialize_maze_grid();

	# Generate the maze structure using recursive backtracking
	# Start carving from a cell within the grid, e.g., (1, 1)
	_generate_maze(1, 1);

	# Create the TileMap node
	tile_map = TileMap.new();
	tile_map.name = \"TileMap\";
	# Position the tilemap at the origin
	tile_map.position = Vector2(0, 0);
	add_child(tile_map);

	# Create the TileSet for the TileMap
	var tile_set = TileSet.new();
	tile_map.tile_set = tile_set;

	# Programmatically create textures for tiles (wall and floor)
	# Create an image that will serve as our texture atlas
	var combined_image = Image.new();
	combined_image.create(TILE_SIZE * 2, TILE_SIZE, false, Image.FORMAT_RGBA8);

	# Create wall texture part
	var wall_image = Image.new();
	wall_image.create(TILE_SIZE, TILE_SIZE, false, Image.FORMAT_RGBA8);
	wall_image.fill(Color.DARKBLUE); # Wall color;
	combined_image.blit_rect(wall_image, Rect2(0, 0, TILE_SIZE, TILE_SIZE), Vector2(0, 0));

	# Create floor texture part
	var floor_image = Image.new();
	floor_image.create(TILE_SIZE, TILE_SIZE, false, Image.FORMAT_RGBA8);
	floor_image.fill(Color.LIGHTGRAY); # Floor color;
	combined_image.blit_rect(floor_image, Rect2(0, 0, TILE_SIZE, TILE_SIZE), Vector2(TILE_SIZE, 0));

	# Create an ImageTexture from the combined image
	var combined_texture = ImageTexture.create_from_image(combined_image);

	# Create an AtlasSource for the TileSet
	var atlas = TileSetAtlasSource.new();
	atlas.texture = combined_texture;
	atlas.region_size = Vector2(TILE_SIZE, TILE_SIZE);
	# The texture_region_size defines the whole area of the texture used
	atlas.texture_region_size = Vector2(TILE_SIZE * 2, TILE_SIZE);

	# Add tiles to the AtlasSource
	# Wall tile (at coordinates 0, 0 in the atlas)
	var wall_coords = Vector2i(0, 0);
	atlas.create_tile(wall_coords);
	var wall_tile_data = atlas.get_tile_data(wall_coords, 0);
	if wall_tile_data:
		wall_tile_data.set_texture_origin(Vector2i(0, 0));
		# Add collision shape to the wall tile
		wall_tile_data.set_collision_history_size(1); # Set history size for collision layer 0;
		wall_tile_data.add_collision_polygon(0, PackedVector2Array([Vector2(0, 0), Vector2(TILE_SIZE, 0), Vector2(TILE_SIZE, TILE_SIZE), Vector2(0, TILE_SIZE)]));

	# Floor tile (at coordinates 1, 0 in the atlas)
	var floor_coords = Vector2i(1, 0);
	atlas.create_tile(floor_coords);
	var floor_tile_data = atlas.get_tile_data(floor_coords, 0);
	if floor_tile_data:
		floor_tile_data.set_texture_origin(Vector2i(0, 0));

	# Add the AtlasSource to the TileSet
	tile_set.add_source(atlas, 0); # Source ID 0;

	# Populate the TileMap based on the generated maze grid
	var map_width = MAZE_WIDTH * 2 + 1;
	var map_height = MAZE_HEIGHT * 2 + 1;
	for x in range(map_width):
		for y in range(map_height):
			if maze_grid[x][y] == WALL_TILE:
				# Set cell using source ID (0), tile coordinates in atlas (wall_coords)
				tile_map.set_cell(0, Vector2i(x, y), 0, wall_coords);
			else:
				# Set floor tile
				tile_map.set_cell(0, Vector2i(x, y), 0, floor_coords);

	# Create player character
	player = CharacterBody2D.new();
	player.name = "Player";
	player.position = Vector2(TILE_SIZE * 1.5, TILE_SIZE * 1.5); # Start position

	# Add sprite to player
	var player_sprite = Sprite2D.new();
	player_sprite.name = "Sprite";

	# Create a simple colored square for the player
	var player_image = Image.new();
	player_image.create(TILE_SIZE, TILE_SIZE, false, Image.FORMAT_RGBA8);
	player_image.fill(Color.RED);
	var player_texture = ImageTexture.create_from_image(player_image);

	player_sprite.texture = player_texture;
	player.add_child(player_sprite);

	# Add collision shape to player
	var player_collision = CollisionShape2D.new();
	player_collision.name = "CollisionShape";
	var shape = RectangleShape2D.new();
	shape.size = Vector2(TILE_SIZE * 0.8, TILE_SIZE * 0.8); # Slightly smaller than tile
	player_collision.shape = shape;
	player.add_child(player_collision);

	add_child(player);

	# Create goal area at the bottom-right of the maze
	goal_area = Area2D.new();
	goal_area.name = "GoalArea";
	goal_area.position = Vector2(TILE_SIZE * (MAZE_WIDTH * 2 - 1.5), TILE_SIZE * (MAZE_HEIGHT * 2 - 1.5));

	# Add sprite to goal
	var goal_sprite = Sprite2D.new();
	goal_sprite.name = "Sprite";

	# Create a simple colored square for the goal
	var goal_image = Image.new();
	goal_image.create(TILE_SIZE, TILE_SIZE, false, Image.FORMAT_RGBA8);
	goal_image.fill(Color.GREEN);
	var goal_texture = ImageTexture.create_from_image(goal_image);

	goal_sprite.texture = goal_texture;
	goal_area.add_child(goal_sprite);

	# Add collision shape to goal
	var goal_collision = CollisionShape2D.new();
	goal_collision.name = "CollisionShape";
	var goal_shape = RectangleShape2D.new();
	goal_shape.size = Vector2(TILE_SIZE, TILE_SIZE);
	goal_collision.shape = goal_shape;
	goal_area.add_child(goal_collision);

	add_child(goal_area);

	# Create win label (initially hidden)
	win_label = Label.new();
	win_label.name = "WinLabel";
	win_label.text = "You Win!";
	win_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER;
	win_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER;
	win_label.position = Vector2(get_viewport_rect().size.x / 2 - 50, get_viewport_rect().size.y / 2 - 25);
	win_label.visible = false;

	add_child(win_label);

	# Connect goal area signal
	goal_area.body_entered.connect(_on_goal_area_body_entered);

# Handle player movement
func _physics_process(delta):
	if not player:
		return
	
	# Get input direction
	var direction = Vector2.ZERO;
	if Input.is_action_pressed("ui_right"):
		direction.x += 1;
	if Input.is_action_pressed("ui_left"):
		direction.x -= 1;
	if Input.is_action_pressed("ui_down"):
		direction.y += 1;
	if Input.is_action_pressed("ui_up"):
		direction.y -= 1;
	
	# Normalize direction to prevent faster diagonal movement
	if direction.length() > 0:
		direction = direction.normalized();
	
	# Set velocity and move
	player.velocity = direction * PLAYER_SPEED;
	player.move_and_slide();

# Handle goal area collision
func _on_goal_area_body_entered(body):
	if body == player:
		# Player reached the goal
		win_label.visible = true;
		# Disable player movement
		player.process_mode = Node.PROCESS_MODE_DISABLED;

"""

[node name="Main" type="Node2D"]
script = SubResource("GDScript_2462143")
