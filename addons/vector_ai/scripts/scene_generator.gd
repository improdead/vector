@tool
extends Node

# Scene Generator
# Creates and modifies scenes with AI-generated code

# Read the current main.tscn file
func read_current_scene():
	var scene_path = "res://main.tscn"

	if FileAccess.file_exists(scene_path):
		var file = FileAccess.open(scene_path, FileAccess.READ)
		var content = file.get_as_text()
		file.close()
		return content

	return ""

# Create a scene with the given code
func create_scene_with_code(code):
	# Get the scene paths - try both resource path and absolute path
	var scene_path = "res://main.tscn"
	var project_dir = ProjectSettings.globalize_path("res://")
	var abs_scene_path = project_dir + "main.tscn"

	# Create temporary file paths with unique names to avoid conflicts
	var random_suffix = str(randi())
	var temp_scene_path = "res://vector_ai_temp_" + random_suffix + ".tscn"
	var abs_temp_scene_path = project_dir + "vector_ai_temp_" + random_suffix + ".tscn"

	print("Creating scene with code")
	print("Resource path: " + scene_path)
	print("Absolute path: " + abs_scene_path)
	print("Temp path: " + abs_temp_scene_path)

	# Clean up the code to ensure proper formatting
	code = clean_code(code)
	print("Code cleaned, length: " + str(code.length()))

	# Create the scene content with embedded script
	var scene_content = """[gd_scene load_steps=2 format=3]

[sub_resource type="GDScript" id="GDScript_main"]
script/source = \"\"\"
# Generated by Vector AI
""" + code + """
\"\"\"

[node name="Main" type="Node2D"]
script = SubResource("GDScript_main")
"""
	print("Scene content created, length: " + str(scene_content.length()))

	# NEW APPROACH: Write to a temporary file first, then use file system operations to replace the original
	print("Using new approach: Write to temp file then replace original")

	# Step 1: Write to temporary file
	var temp_file = FileAccess.open(abs_temp_scene_path, FileAccess.WRITE)
	if temp_file == null:
		print("Failed to create temporary file")
		return {
			"success": false,
			"message": "Failed to create temporary file"
		}

	temp_file.store_string(scene_content)
	temp_file.close()
	print("Temporary file created successfully")

	# Step 2: Verify the temporary file was written correctly
	if not FileAccess.file_exists(abs_temp_scene_path):
		print("Temporary file was not created successfully")
		return {
			"success": false,
			"message": "Temporary file was not created successfully"
		}

	# Step 3: Use PowerShell to replace the original file with the temporary file
	var output = []
	var ps_command = "Move-Item -Path '" + abs_temp_scene_path + "' -Destination '" + abs_scene_path + "' -Force"
	print("PowerShell command: " + ps_command)

	var exit_code = OS.execute("powershell", ["-Command", ps_command], output)
	print("PowerShell exit code: " + str(exit_code))
	print("PowerShell output: " + str(output))

	var result = {
		"success": exit_code == 0,
		"message": "Scene created successfully using file replacement approach"
	}

	if not result.success:
		print("Failed to replace original file with temporary file")

		# Fallback: Try to copy the content directly
		print("Trying direct file copy as fallback...")

		# Read the temporary file
		var temp_content = ""
		var read_temp = FileAccess.open(abs_temp_scene_path, FileAccess.READ)
		if read_temp != null:
			temp_content = read_temp.get_as_text()
			read_temp.close()

			# Write directly to the target file
			var target_file = FileAccess.open(abs_scene_path, FileAccess.WRITE)
			if target_file != null:
				target_file.store_string(temp_content)
				target_file.close()
				print("Direct file copy successful")

				result = {
					"success": true,
					"message": "Scene created successfully using direct file copy"
				}
			else:
				print("Failed to open target file for writing")

	# Also create a backup copy that the user can access if needed
	var backup_path = project_dir + "vector_ai_generated.tscn"
	var backup_file = FileAccess.open(backup_path, FileAccess.WRITE)
	if backup_file != null:
		backup_file.store_string(scene_content)
		backup_file.close()
		print("Backup file created at: " + backup_path)

		# Add backup info to result
		result.backup_path = backup_path

	# CRITICAL: Make sure the main.tscn file is always updated
	# This is a direct approach to ensure the file is written
	print("CRITICAL: Ensuring main.tscn is updated...")
	var main_file = FileAccess.open(abs_scene_path, FileAccess.WRITE)
	if main_file != null:
		main_file.store_string(scene_content)
		main_file.close()
		print("main.tscn directly updated")

		# Force the result to success
		result.success = true
		result.message = "Scene created successfully at " + abs_scene_path + " (direct write)"

	if result.success:
		# File was written successfully, now ensure Godot reloads it
		print("File written successfully, ensuring Godot reloads it...")

		# EXTREME APPROACH: Create a completely new file with a different name, then rename it to main.tscn
		print("Using extreme approach to force Godot to detect changes...")

		# Step 1: Create a new file with a different name
		var extreme_file_name = "vector_ai_extreme_" + str(randi()) + ".tscn"
		var abs_extreme_path = project_dir + extreme_file_name

		# Step 2: Write the content to this new file
		var extreme_file = FileAccess.open(abs_extreme_path, FileAccess.WRITE)
		if extreme_file != null:
			extreme_file.store_string(scene_content)
			extreme_file.close()
			print("Extreme file created at: " + abs_extreme_path)

			# Step 3: Use PowerShell to replace the original file with this new file
			var extreme_output = []
			var extreme_command = "Move-Item -Path '" + abs_extreme_path + "' -Destination '" + abs_scene_path + "' -Force"
			var extreme_exit_code = OS.execute("powershell", ["-Command", extreme_command], extreme_output)

			if extreme_exit_code == 0:
				print("Extreme file replacement successful!")
			else:
				print("Extreme file replacement failed: " + str(extreme_output))

		# Try all our regular reload methods too
		var reload_result = ensure_godot_reloads_scene(abs_scene_path)

		# Add reload result to the original result
		result.reload_success = reload_result.success
		result.reload_message = reload_result.message

		if not reload_result.success:
			# Add a note about manual reload
			result.message += "\nNOTE: Automatic reload may have failed. Please try manually reloading the scene in the editor."

		# Force a direct modification to the file to ensure Godot detects the change
		print("Applying additional file modification to force detection...")
		try_timestamp_modification(abs_scene_path)

		# Also try to force Godot to reload by modifying the file system
		print("Forcing file system update...")
		var fs_output = []
		var fs_command = "Get-ChildItem -Path '" + project_dir + "' -Recurse | Where-Object { $_.Name -eq 'main.tscn' } | ForEach-Object { $_.LastWriteTime = Get-Date }"
		OS.execute("powershell", ["-Command", fs_command], fs_output)

		# Try to force Godot to reload by creating a small change and then changing it back
		print("Forcing reload with small change trick...")
		var trick_output = []
		var trick_command = """
		$content = Get-Content -Path '""" + abs_scene_path + """' -Raw
		$content += '# Force reload'
		Set-Content -Path '""" + abs_scene_path + """' -Value $content -Force
		Start-Sleep -Milliseconds 500
		Set-Content -Path '""" + abs_scene_path + """' -Value $content.Replace('# Force reload', '') -Force
		"""
		OS.execute("powershell", ["-Command", trick_command], trick_output)

	print("Scene creation result: " + str(result.success) + " - " + result.message)
	return result

# Create a scene file using PowerShell directly
func create_scene_with_powershell(path, content):
	print("Attempting to write file directly using PowerShell: " + path)

	# Create a temporary file with the content
	var temp_dir = OS.get_executable_path().get_base_dir()
	var temp_path = temp_dir + "/temp_scene.txt"
	var temp_path_random = temp_dir + "/temp_scene_" + str(randi()) + ".txt"

	# Write content to temporary file
	var file = FileAccess.open(temp_path, FileAccess.WRITE)
	if file == null:
		print("Failed to create temporary file")
		return {
			"success": false,
			"message": "Failed to create temporary file"
		}

	file.store_string(content)
	file.close()

	print("Temporary file created at: " + temp_path)

	# First try: Use PowerShell to write the file with Out-File (better for large files)
	var output = []
	var ps_command = "Get-Content -Path '" + temp_path + "' -Raw | Out-File -FilePath '" + path + "' -Encoding utf8 -Force"
	print("PowerShell command: " + ps_command)

	var exit_code = OS.execute("powershell", ["-Command", ps_command], output)

	print("PowerShell exit code: " + str(exit_code))
	print("PowerShell output: " + str(output))

	if exit_code != 0:
		# Try alternative approach with Copy-Item
		print("First method failed, trying Copy-Item...")

		# Create a second temporary file with a different name
		var file2 = FileAccess.open(temp_path_random, FileAccess.WRITE)
		if file2 != null:
			file2.store_string(content)
			file2.close()

			# Use Copy-Item which might work better in some cases
			var output2 = []
			var ps_command2 = "Copy-Item -Path '" + temp_path_random + "' -Destination '" + path + "' -Force"

			var exit_code2 = OS.execute("powershell", ["-Command", ps_command2], output2)

			if exit_code2 != 0:
				return {
					"success": false,
					"message": "Failed to write file using both PowerShell methods: " + str(output) + " and " + str(output2)
				}
		else:
			return {
				"success": false,
				"message": "Failed to write file using PowerShell: " + str(output)
			}

	print("File written successfully using PowerShell!")

	# Verify the file was written
	var verify_output = []
	var verify_command = "Test-Path -Path '" + path + "'"
	var verify_exit_code = OS.execute("powershell", ["-Command", verify_command], verify_output)

	if verify_exit_code == 0 and verify_output.size() > 0 and verify_output[0].strip_edges() == "True":
		print("File existence verified with PowerShell!")

		# Also try to verify the content length
		var content_verify_output = []
		var content_verify_command = "(Get-Content -Path '" + path + "' -Raw).Length"
		var content_verify_exit_code = OS.execute("powershell", ["-Command", content_verify_command], content_verify_output)

		if content_verify_exit_code == 0 and content_verify_output.size() > 0:
			print("File content length verified: " + content_verify_output[0].strip_edges())
	else:
		print("WARNING: File existence could not be verified with PowerShell!")
		return {
			"success": false,
			"message": "File existence could not be verified with PowerShell"
		}

	# Try to force Godot to detect the change by modifying the file timestamp
	var timestamp_output = []
	var timestamp_command = "(Get-Item -Path '" + path + "').LastWriteTime = Get-Date"
	OS.execute("powershell", ["-Command", timestamp_command], timestamp_output)
	print("File timestamp updated to force detection")

	return {
		"success": true,
		"message": "Scene created successfully at " + path + " using PowerShell"
	}

# Create a scene file using OS.execute
func create_scene_with_os_execute(path, content):
	print("Attempting to write file using OS.execute: " + path)

	# Create a temporary file with the content
	var temp_path = OS.get_executable_path().get_base_dir() + "/temp_scene.txt"
	var file = FileAccess.open(temp_path, FileAccess.WRITE)
	if file == null:
		print("Failed to create temporary file")
		return {
			"success": false,
			"message": "Failed to create temporary file"
		}

	file.store_string(content)
	file.close()

	print("Temporary file created at: " + temp_path)

	# Use PowerShell to copy the file
	var output = []
	var ps_command = "Copy-Item -Path '" + temp_path + "' -Destination '" + path + "' -Force"
	print("PowerShell command: " + ps_command)

	var exit_code = OS.execute("powershell", ["-Command", ps_command], output)

	print("PowerShell exit code: " + str(exit_code))
	print("PowerShell output: " + str(output))

	if exit_code != 0:
		return {
			"success": false,
			"message": "Failed to copy file using PowerShell: " + str(output)
		}

	print("File copied successfully using PowerShell!")

	return {
		"success": true,
		"message": "Scene created successfully at " + path + " using PowerShell"
	}

# Clean up the code to ensure proper formatting
func clean_code(code):
	print("Cleaning code...")

	# Remove any duplicate 'extends' statements
	var lines = code.split("\n")
	var cleaned_lines = []
	var found_extends = false

	for line in lines:
		var trimmed = line.strip_edges()

		# Check if this is an 'extends' line
		if trimmed.begins_with("extends"):
			# If we've already found an 'extends' statement, skip this line
			if found_extends:
				print("Skipping duplicate extends statement: " + trimmed)
				continue

			# Otherwise, mark that we've found one and keep it
			found_extends = true

		# Add the line to our cleaned lines
		cleaned_lines.append(line)

	# Rejoin the lines
	code = "\n".join(cleaned_lines)

	# Make sure the code starts with 'extends'
	if not code.strip_edges().begins_with("extends"):
		print("Adding missing extends statement")
		code = "extends Node2D\n\n" + code

	# Make sure there's a newline at the end
	if not code.ends_with("\n"):
		code += "\n"

	print("Code cleaning complete")
	return code

# Create or update a scene file
func create_scene(path, content):
	print("Attempting to write to file: " + path)

	# Check if the directory exists
	var dir_path = path.get_base_dir()
	print("Directory path: " + dir_path)

	if not DirAccess.dir_exists_absolute(dir_path):
		print("Directory does not exist, creating it...")
		var dir_error = DirAccess.make_dir_recursive_absolute(dir_path)
		if dir_error != OK:
			print("Failed to create directory: " + str(dir_error))
			return {
				"success": false,
				"message": "Failed to create directory: " + str(dir_error)
			}

	# Try to create or update the file
	print("Opening file for writing...")
	var file = FileAccess.open(path, FileAccess.WRITE)
	if file == null:
		var error = FileAccess.get_open_error()
		print("Failed to open file for writing: " + str(error))
		return {
			"success": false,
			"message": "Failed to open file for writing: " + str(error)
		}

	print("Writing content to file...")
	file.store_string(content)
	file.close()

	# Verify the file was written
	if FileAccess.file_exists(path):
		print("File exists after writing!")

		# Try to read the file back to verify content
		var verify_file = FileAccess.open(path, FileAccess.READ)
		if verify_file != null:
			var verify_content = verify_file.get_as_text()
			verify_file.close()

			if verify_content.length() > 0:
				print("File content verified, length: " + str(verify_content.length()))
			else:
				print("WARNING: File exists but content is empty!")
		else:
			print("WARNING: File exists but cannot be read!")
	else:
		print("WARNING: File does not exist after writing!")
		return {
			"success": false,
			"message": "File does not exist after writing!"
		}

	print("File written successfully!")
	return {
		"success": true,
		"message": "Scene created successfully at " + path
	}

# Ensure Godot reloads the scene file
func ensure_godot_reloads_scene(path):
	print("Ensuring Godot reloads the scene...")

	# Method 1: Try using EditorInterface
	var result = try_editor_interface_reload(path)
	if result.success:
		return result

	# Method 2: Try using ResourceLoader
	result = try_resource_loader_reload(path)
	if result.success:
		return result

	# Method 3: Try modifying the file timestamp
	result = try_timestamp_modification(path)
	if result.success:
		return result

	# All methods failed
	return {
		"success": false,
		"message": "Failed to ensure Godot reloads the scene. Please try manually reloading the scene in the editor."
	}

# Try using EditorInterface to reload the scene
func try_editor_interface_reload(path):
	print("Trying EditorInterface reload...")

	# Get the plugin instance
	var plugin = get_plugin_instance()
	if not plugin:
		return {
			"success": false,
			"message": "Cannot access EditorInterface (no plugin instance)"
		}

	# Try to get the EditorInterface
	var editor_interface = plugin.get_editor_interface()
	if not editor_interface:
		return {
			"success": false,
			"message": "Cannot access EditorInterface"
		}

	# Try to reload the scene
	print("Calling reload_scene_from_path with: " + path)
	editor_interface.reload_scene_from_path(path)

	# Also try to get the FileSystem and scan
	var filesystem = editor_interface.get_resource_filesystem()
	if filesystem:
		print("Scanning filesystem...")
		filesystem.scan()
		filesystem.scan_sources()

	return {
		"success": true,
		"message": "Attempted to reload scene using EditorInterface"
	}

# Try using ResourceLoader to reload the scene
func try_resource_loader_reload(path):
	print("Trying ResourceLoader reload...")

	# Convert absolute path to resource path if needed
	var resource_path = path
	if not path.begins_with("res://"):
		# Try to convert to resource path
		var project_dir = ProjectSettings.globalize_path("res://")
		if path.begins_with(project_dir):
			resource_path = "res://" + path.substr(project_dir.length())
		else:
			print("Cannot convert absolute path to resource path: " + path)
			return {
				"success": false,
				"message": "Cannot convert absolute path to resource path"
			}

	# Try to reload the resource
	print("Reloading resource: " + resource_path)
	if ResourceLoader.has_cached(resource_path):
		ResourceLoader.load(resource_path, "", ResourceLoader.CACHE_MODE_REPLACE)
		print("Resource reloaded")
		return {
			"success": true,
			"message": "Resource reloaded using ResourceLoader"
		}
	else:
		print("Resource not cached, loading for the first time")
		var resource = ResourceLoader.load(resource_path)
		if resource:
			print("Resource loaded successfully")
			return {
				"success": true,
				"message": "Resource loaded using ResourceLoader"
			}
		else:
			print("Failed to load resource")
			return {
				"success": false,
				"message": "Failed to load resource using ResourceLoader"
			}

# Try modifying the file timestamp to force Godot to detect the change
func try_timestamp_modification(path):
	print("Trying timestamp modification...")

	# Method 1: Use PowerShell to touch the file (update its timestamp)
	var output = []
	var ps_command = "(Get-Item -Path '" + path + "').LastWriteTime = Get-Date"

	var exit_code = OS.execute("powershell", ["-Command", ps_command], output)

	if exit_code != 0:
		print("Failed to update file timestamp with PowerShell: " + str(output))
	else:
		print("File timestamp updated with PowerShell")

	# Method 2: Try to create a small temporary change to force detection
	# This is a more aggressive approach that should definitely trigger a reload
	var resource_path = path
	if not path.begins_with("res://"):
		# Try to convert to resource path
		var project_dir = ProjectSettings.globalize_path("res://")
		if path.begins_with(project_dir):
			resource_path = "res://" + path.substr(project_dir.length())

	# Read the current content
	var current_content = ""
	if FileAccess.file_exists(path):
		var file = FileAccess.open(path, FileAccess.READ)
		if file != null:
			current_content = file.get_as_text()
			file.close()

	if not current_content.is_empty():
		# Add a tiny whitespace change that won't affect functionality
		# but will force Godot to detect the change
		var modified_content = current_content
		if not modified_content.ends_with("\n\n"):
			modified_content += "\n"

		# Write it back
		var file = FileAccess.open(path, FileAccess.WRITE)
		if file != null:
			file.store_string(modified_content)
			file.close()
			print("Added small change to force file reload detection")

	# Method 3: Try to force a resource reimport
	if ResourceLoader.has_cached(resource_path):
		ResourceLoader.load(resource_path, "", ResourceLoader.CACHE_MODE_REPLACE)
		print("Resource cache replaced")

	return {
		"success": true,
		"message": "Multiple methods used to force file reload detection"
	}

# Helper function to get the plugin instance
func get_plugin_instance():
	# This assumes the script has a way to access the plugin instance
	# It might be passed in or accessible through a parent node
	var parent = get_parent()
	while parent:
		if parent.has_method("get_editor_interface"):
			return parent

		# Check if parent has a plugin property using get() which is safer than has_property
		if parent.get("plugin") != null:
			return parent.plugin

		parent = parent.get_parent()

	return null
